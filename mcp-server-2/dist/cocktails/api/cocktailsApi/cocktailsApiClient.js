//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import { CocktailsApiClientBase } from './cocktailsApiClientBase.js';
import axios from 'axios';
export class CocktailsApiClient extends CocktailsApiClientBase {
    constructor(baseUrl, instance) {
        super();
        this.jsonParseReviver = undefined;
        this.instance = instance || axios.create();
        this.baseUrl = this.getBaseUrl();
    }
    /**
     * @param freeText (optional) The free text search term to match against
     * @param skip (optional) The number of cocktail recipes to skip from the paged response
     * @param take (optional) The number of cocktail recipes to return
     * @param m (optional) A list of cocktails that can be included in the list
     * @param match_exclusive (optional) Whether or not the supplied matches must be exclusively returned
     * @param inc (optional) The list of extension objects to include for each cocktail recipe
     * @param sf (optional) An optional list of filters to use when quering the cocktail recipes
     * @param x_Key (optional) Subscription key
     * @return OK
     */
    getCocktailsList(freeText, skip, take, m, match_exclusive, inc, sf, x_Key, cancelToken) {
        let url_ = this.baseUrl + "/api/v1/cocktails?";
        if (freeText === null)
            throw new Error("The parameter 'freeText' cannot be null.");
        else if (freeText !== undefined)
            url_ += "freeText=" + encodeURIComponent("" + freeText) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (m === null)
            throw new Error("The parameter 'm' cannot be null.");
        else if (m !== undefined)
            m && m.forEach(item => { url_ += "m=" + encodeURIComponent("" + item) + "&"; });
        if (match_exclusive === null)
            throw new Error("The parameter 'match_exclusive' cannot be null.");
        else if (match_exclusive !== undefined)
            url_ += "match-exclusive=" + encodeURIComponent("" + match_exclusive) + "&";
        if (inc === null)
            throw new Error("The parameter 'inc' cannot be null.");
        else if (inc !== undefined)
            inc && inc.forEach(item => { url_ += "inc=" + encodeURIComponent("" + item) + "&"; });
        if (sf === null)
            throw new Error("The parameter 'sf' cannot be null.");
        else if (sf !== undefined)
            sf && sf.forEach(item => { url_ += "sf=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Accept": "application/json; x-api-version=1.0"
            },
            cancelToken
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.transformResult(url_, _response, (_response) => this.processGetCocktailsList(_response));
        });
    }
    processGetCocktailsList(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * @param x_Key (optional) Subscription key
     * @return No Content
     */
    seedCocktails(x_Key, cancelToken) {
        let url_ = this.baseUrl + "/api/v1/cocktails";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "PUT",
            url: url_,
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
            },
            cancelToken
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.transformResult(url_, _response, (_response) => this.processSeedCocktails(_response));
        });
    }
    processSeedCocktails(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve(null);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * @param id The cocktail recipe unique identifier
     * @param x_Key (optional) Subscription key
     * @return OK
     */
    getCocktail(id, x_Key, cancelToken) {
        let url_ = this.baseUrl + "/api/v1/cocktails/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Accept": "application/json; x-api-version=1.0"
            },
            cancelToken
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.transformResult(url_, _response, (_response) => this.processGetCocktail(_response));
        });
    }
    processGetCocktail(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * @param x_Key (optional) Subscription key
     * @return OK
     */
    getCocktailIngredientFilters(x_Key, cancelToken) {
        let url_ = this.baseUrl + "/api/v1/cocktails/ingredients/filters";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Accept": "application/json; x-api-version=1.0"
            },
            cancelToken
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.transformResult(url_, _response, (_response) => this.processGetCocktailIngredientFilters(_response));
        });
    }
    processGetCocktailIngredientFilters(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * @param x_Key (optional) Subscription key
     * @return No Content
     */
    seedIngredients(x_Key, cancelToken) {
        let url_ = this.baseUrl + "/api/v1/cocktails/ingredients";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "PUT",
            url: url_,
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
            },
            cancelToken
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.transformResult(url_, _response, (_response) => this.processSeedIngredients(_response));
        });
    }
    processSeedIngredients(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve(null);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * @param x_Key (optional) Subscription key
     * @return OK
     */
    getPrivacyPolicy(x_Key, cancelToken) {
        let url_ = this.baseUrl + "/api/v1/legal/documents/privacy-policy";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Accept": "application/json; x-api-version=1.0"
            },
            cancelToken
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.transformResult(url_, _response, (_response) => this.processGetPrivacyPolicy(_response));
        });
    }
    processGetPrivacyPolicy(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * @param x_Key (optional) Subscription key
     * @return OK
     */
    getTermsOfService(x_Key, cancelToken) {
        let url_ = this.baseUrl + "/api/v1/legal/documents/terms-of-service";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Accept": "application/json; x-api-version=1.0"
            },
            cancelToken
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.transformResult(url_, _response, (_response) => this.processGetTermsOfService(_response));
        });
    }
    processGetTermsOfService(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * @param x_Key (optional) Subscription key
     * @return OK
     */
    getAccountOwnedProfile(x_Key, cancelToken) {
        let url_ = this.baseUrl + "/api/v1/accounts/owned/profile";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Accept": "application/json; x-api-version=1.0"
            },
            cancelToken
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.transformResult(url_, _response, (_response) => this.processGetAccountOwnedProfile(_response));
        });
    }
    processGetAccountOwnedProfile(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * @param x_Key (optional) Subscription key
     * @param body (optional)
     * @return OK
     */
    updateAccountOwnedProfile(x_Key, body, cancelToken) {
        let url_ = this.baseUrl + "/api/v1/accounts/owned/profile";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "application/json; x-api-version=1.0"
            },
            cancelToken
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.transformResult(url_, _response, (_response) => this.processUpdateAccountOwnedProfile(_response));
        });
    }
    processUpdateAccountOwnedProfile(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * @param x_Key (optional) Subscription key
     * @param body (optional)
     * @return OK
     */
    updateAccountOwnedProfileEmail(x_Key, body, cancelToken) {
        let url_ = this.baseUrl + "/api/v1/accounts/owned/profile/email";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "application/json; x-api-version=1.0"
            },
            cancelToken
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.transformResult(url_, _response, (_response) => this.processUpdateAccountOwnedProfileEmail(_response));
        });
    }
    processUpdateAccountOwnedProfileEmail(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * @param x_Key (optional) Subscription key
     * @param body (optional)
     * @return OK
     */
    updateAccountOwnedAccessibilitySettings(x_Key, body, cancelToken) {
        let url_ = this.baseUrl + "/api/v1/accounts/owned/profile/accessibility";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "application/json; x-api-version=1.0"
            },
            cancelToken
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.transformResult(url_, _response, (_response) => this.processUpdateAccountOwnedAccessibilitySettings(_response));
        });
    }
    processUpdateAccountOwnedAccessibilitySettings(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * @param x_Key (optional) Subscription key
     * @return Created
     */
    uploadProfileImage(body, x_Key, cancelToken) {
        let url_ = this.baseUrl + "/api/v1/accounts/owned/profile/image";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Content-Type": "multipart/form-data; x-api-version=1.0",
                "Accept": "application/json; x-api-version=1.0"
            },
            cancelToken
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.transformResult(url_, _response, (_response) => this.processUploadProfileImage(_response));
        });
    }
    processUploadProfileImage(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201 = null;
            let resultData201 = _responseText;
            result201 = JSON.parse(resultData201);
            return Promise.resolve(result201);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * @param x_Key (optional) Subscription key
     * @param body (optional)
     * @return OK
     */
    manageFavoriteCocktails(x_Key, body, cancelToken) {
        let url_ = this.baseUrl + "/api/v1/accounts/owned/profile/cocktails/favorites";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "application/json; x-api-version=1.0"
            },
            cancelToken
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.transformResult(url_, _response, (_response) => this.processManageFavoriteCocktails(_response));
        });
    }
    processManageFavoriteCocktails(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * @param x_Key (optional) Subscription key
     * @param body (optional)
     * @return Created
     */
    rateCocktail(x_Key, body, cancelToken) {
        let url_ = this.baseUrl + "/api/v1/accounts/owned/profile/cocktails/ratings";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Content-Type": "application/json; x-api-version=1.0",
                "Accept": "application/json; x-api-version=1.0"
            },
            cancelToken
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.transformResult(url_, _response, (_response) => this.processRateCocktail(_response));
        });
    }
    processRateCocktail(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201 = null;
            let resultData201 = _responseText;
            result201 = JSON.parse(resultData201);
            return Promise.resolve(result201);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * @param x_Key (optional) Subscription key
     * @return OK
     */
    getCocktailRatings(x_Key, cancelToken) {
        let url_ = this.baseUrl + "/api/v1/accounts/owned/profile/cocktails/ratings";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Accept": "application/json; x-api-version=1.0"
            },
            cancelToken
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.transformResult(url_, _response, (_response) => this.processGetCocktailRatings(_response));
        });
    }
    processGetCocktailRatings(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }
    /**
     * @param body The cocktail recommendation request body
     * @param x_Key (optional) Subscription key
     * @return Accepted
     */
    sendCocktailRecommendation(body, x_Key, cancelToken) {
        let url_ = this.baseUrl + "/api/v1/accounts/owned/profile/cocktails/recommendations";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "X-Key": x_Key !== undefined && x_Key !== null ? "" + x_Key : "",
                "Content-Type": "application/json; x-api-version=1.0",
            },
            cancelToken
        };
        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        }).then((_response) => {
            return this.transformResult(url_, _response, (_response) => this.processSendCocktailRecommendation(_response));
        });
    }
    processSendCocktailRecommendation(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            return Promise.resolve(null);
        }
        else {
            const _responseText = response.data;
            let resultdefault = null;
            let resultDatadefault = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
        }
    }
}
export var CocktailDataIncludeModel;
(function (CocktailDataIncludeModel) {
    CocktailDataIncludeModel["MainImages"] = "mainImages";
    CocktailDataIncludeModel["SearchTiles"] = "searchTiles";
    CocktailDataIncludeModel["DescriptiveTitle"] = "descriptiveTitle";
})(CocktailDataIncludeModel || (CocktailDataIncludeModel = {}));
/** The action to take on the cocktail within the favorites list */
export var CocktailFavoritingActionModel;
(function (CocktailFavoritingActionModel) {
    CocktailFavoritingActionModel["Add"] = "add";
    CocktailFavoritingActionModel["Remove"] = "remove";
})(CocktailFavoritingActionModel || (CocktailFavoritingActionModel = {}));
/** The accessibility theme */
export var DisplayThemeModel;
(function (DisplayThemeModel) {
    DisplayThemeModel["Light"] = "light";
    DisplayThemeModel["Dark"] = "dark";
})(DisplayThemeModel || (DisplayThemeModel = {}));
/** The display theme (light, dark) */
export var DisplayThemeModel2;
(function (DisplayThemeModel2) {
    DisplayThemeModel2["Light"] = "light";
    DisplayThemeModel2["Dark"] = "dark";
})(DisplayThemeModel2 || (DisplayThemeModel2 = {}));
/** The format that the document content is in */
export var DocumentFormat;
(function (DocumentFormat) {
    DocumentFormat["Markdown"] = "markdown";
})(DocumentFormat || (DocumentFormat = {}));
export var GlasswareTypeModel;
(function (GlasswareTypeModel) {
    GlasswareTypeModel["None"] = "none";
    GlasswareTypeModel["Rocks"] = "rocks";
    GlasswareTypeModel["Highball"] = "highball";
    GlasswareTypeModel["ShotGlass"] = "shotGlass";
    GlasswareTypeModel["Coupe"] = "coupe";
    GlasswareTypeModel["CopperMug"] = "copperMug";
    GlasswareTypeModel["Collins"] = "collins";
    GlasswareTypeModel["CocktailGlass"] = "cocktailGlass";
    GlasswareTypeModel["WineGlass"] = "wineGlass";
    GlasswareTypeModel["Flute"] = "flute";
    GlasswareTypeModel["Lowball"] = "lowball";
    GlasswareTypeModel["Fizz"] = "fizz";
    GlasswareTypeModel["TikiMug"] = "tikiMug";
    GlasswareTypeModel["PintGlass"] = "pintGlass";
    GlasswareTypeModel["JulepTin"] = "julepTin";
    GlasswareTypeModel["DoubleRocks"] = "doubleRocks";
    GlasswareTypeModel["Hurricane"] = "hurricane";
    GlasswareTypeModel["HollowedPineapple"] = "hollowedPineapple";
    GlasswareTypeModel["Snifter"] = "snifter";
    GlasswareTypeModel["ScorpionBowl"] = "scorpionBowl";
})(GlasswareTypeModel || (GlasswareTypeModel = {}));
export var IngredientApplicationModel;
(function (IngredientApplicationModel) {
    IngredientApplicationModel["Base"] = "base";
    IngredientApplicationModel["Additional"] = "additional";
    IngredientApplicationModel["Garnishment"] = "garnishment";
    IngredientApplicationModel["Muddle"] = "muddle";
})(IngredientApplicationModel || (IngredientApplicationModel = {}));
/** Whether or not this ingredient is required ('Required' or 'Optional') */
export var IngredientRequirementTypeModel;
(function (IngredientRequirementTypeModel) {
    IngredientRequirementTypeModel["None"] = "none";
    IngredientRequirementTypeModel["Optional"] = "optional";
    IngredientRequirementTypeModel["Required"] = "required";
})(IngredientRequirementTypeModel || (IngredientRequirementTypeModel = {}));
export var IngredientTypeModel;
(function (IngredientTypeModel) {
    IngredientTypeModel["Herb"] = "herb";
    IngredientTypeModel["Fruit"] = "fruit";
    IngredientTypeModel["Juice"] = "juice";
    IngredientTypeModel["Bitters"] = "bitters";
    IngredientTypeModel["Syrup"] = "syrup";
    IngredientTypeModel["Protein"] = "protein";
    IngredientTypeModel["Flowers"] = "flowers";
    IngredientTypeModel["Sauce"] = "sauce";
    IngredientTypeModel["Vegetable"] = "vegetable";
    IngredientTypeModel["Dilution"] = "dilution";
    IngredientTypeModel["Beer"] = "beer";
    IngredientTypeModel["Spirit"] = "spirit";
    IngredientTypeModel["Liqueur"] = "liqueur";
    IngredientTypeModel["Wine"] = "wine";
    IngredientTypeModel["Champagne"] = "champagne";
})(IngredientTypeModel || (IngredientTypeModel = {}));
/** Any preparation that should be made with this ingredient */
export var PreparationTypeModel;
(function (PreparationTypeModel) {
    PreparationTypeModel["None"] = "none";
    PreparationTypeModel["Chilled"] = "chilled";
    PreparationTypeModel["FreshlySqueezed"] = "freshlySqueezed";
    PreparationTypeModel["PeeledAndJuiced"] = "peeledAndJuiced";
    PreparationTypeModel["FreshlyGrated"] = "freshlyGrated";
    PreparationTypeModel["Quartered"] = "quartered";
    PreparationTypeModel["FreshPressed"] = "freshPressed";
})(PreparationTypeModel || (PreparationTypeModel = {}));
/** The unit of measure when using this ingredient in a cocktail recipe */
export var UofMTypeModel;
(function (UofMTypeModel) {
    UofMTypeModel["None"] = "none";
    UofMTypeModel["Ounces"] = "ounces";
    UofMTypeModel["Dashes"] = "dashes";
    UofMTypeModel["Tablespoon"] = "tablespoon";
    UofMTypeModel["Topoff"] = "topoff";
    UofMTypeModel["Item"] = "item";
    UofMTypeModel["Teaspoon"] = "teaspoon";
    UofMTypeModel["ToTaste"] = "toTaste";
    UofMTypeModel["Barspoon"] = "barspoon";
    UofMTypeModel["Cups"] = "cups";
    UofMTypeModel["Splash"] = "splash";
    UofMTypeModel["Discretion"] = "discretion";
})(UofMTypeModel || (UofMTypeModel = {}));
export class CocktailsApiClientException extends Error {
    constructor(message, status, response, headers, result) {
        super();
        this.isCocktailsApiClientException = true;
        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }
    static isCocktailsApiClientException(obj) {
        return obj.isCocktailsApiClientException === true;
    }
}
function throwException(message, status, response, headers, result) {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new CocktailsApiClientException(message, status, response, headers, null);
}
function isAxiosError(obj) {
    return obj && obj.isAxiosError === true;
}
/* tslint:disable */
/* eslint-disable */
if (CocktailsApiClientBase) { }
